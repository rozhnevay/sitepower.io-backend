#!/usr/bin/env node

/**
 * Module dependencies.
 */


var db = require('../queries');
var debug = require('debug')('sitepower.io-backend:server');
var http = require('http');
var app = require('../app');
/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);
var io = require('socket.io').listen(server);

/**
 * Listen on provided port, on all network interfaces.
 */
const session = require('express-session');
const redisStore = require('connect-redis')(session);
var passportSocketIo = require("passport.socketio");



server.listen(port);
var store = new redisStore()
io.use(passportSocketIo.authorize({
  passport:     app.passport,
  secret:       process.env.SECRET,
  key:          'sitepower.sid',       // the name of the cookie where express/connect stores its session_id
  store:        store,        // we NEED to use a sessionstore. no memorystore please
  success:      onAuthorizeSuccess,  // *optional* callback on success - read more below
  fail:         onAuthorizeFail,     // *optional* callback on fail/error - read more below
}));

function onAuthorizeSuccess(data, accept){
  console.log('successful connection to socket.io');
  accept();
}

function onAuthorizeFail(data, message, error, accept){
  if(error)
    throw new Error(message);
  console.log('failed connection to socket.io:', message);
  accept(null, false);
}

let userChats = {};
let prospectChats = {};

io.on('connect', function (socket) {
  //console.log("user:" + socket.request.user.id);
  //console.log("client:" + socket.client.id);
  //console.log("token = " + socket.handshake.query.token);

  if (socket.request.user.id) {
    console.log("user");
    //db.updateUserChatId(socket.request.user.id, socket.client.id).then(res => console.log(success)).catch(err => err);
    userChats[socket.request.user.sitepower_id] = socket.client.id;
  } else if (socket.handshake.query.sitepower_id) {
    console.log("1");
    prospectChats[socket.handshake.query.sitepower_id] = socket.client.id;
    /*db.updateProspectChatId(socket.handshake.query.sitepower_id, socket.client.id).then(
        (res) => db.getProspectUserBySPId(socket.handshake.query.sitepower_id).then(
            res => db.getChatIdByUserId(res.user_id).then (
                res => socket.direction = res
            ).catch(err => console.log(err))
         ).catch(err => console.log(err))
    ).catch(err => console.log(err));*/
  }
})

io.on('connection', function(socket){
  console.log("direction = " + socket.direction);


  socket.on('send', function(msg){
    console.log("{SEND} [recepient_id = " + msg.recepient_id +"] [direction = " + msg.direction + "]");
    console.log("prospectChats");
    console.log(prospectChats);
    console.log("userChats");
    console.log(userChats);
    if (msg.direction == "from_user"){
      directChatId = prospectChats[msg.recepient_id];
    } else {
      directChatId = userChats[msg.recepient_id];
    }
    console.log("directChatId = " + directChatId);
    //console.log("io.clients");
    //console.log(io.clients);
    //io.clients[directChatId].send(msg);
    //io.emit("receive", msg)
    io.to(directChatId).emit("receive", msg)
  });
});
server.on('error', onError);
server.on('listening', onListening);



/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
